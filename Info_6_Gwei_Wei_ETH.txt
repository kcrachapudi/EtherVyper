Understanding Ether Denominations: Wei, Gwei, and ETH in Vyper
When developing smart contracts on Ethereum, interacting with its native currency, Ether (ETH), is fundamental. While users typically think in terms of ETH, the Ethereum Virtual Machine (EVM) and smart contracts operate at a much finer level of granularity. This lesson explores the different denominations of Ether, focusing on Wei, and explains how to handle Ether values correctly and readably within Vyper smart contracts.

The Units of Ether: Ether, Gwei, and Wei
Ether (ETH) is the primary unit you see referenced in exchanges and wallets. However, for precision and to avoid floating-point issues, Ethereum uses smaller denominations internally:

Ether (ETH): The standard unit (e.g., 1 ETH).

Gwei (Gigawei): Commonly used for gas prices. 1 ETH = 1,000,000,000 Gwei (1 billion Gwei, or 1e9).

Wei: The smallest possible unit of Ether. All value calculations within smart contracts happen in Wei. 1 ETH = 1,000,000,000,000,000,000 Wei (1 quintillion Wei, or 1 * 10^18).

Understanding this hierarchy is crucial. While you might want a user to send 1 ETH to your contract, the contract itself will receive and process that value in Wei.

Handling Incoming Ether: The msg.value Global Variable
In Vyper, when a function needs to receive Ether as part of a transaction, it must be marked with the @payable decorator. Within such functions, a special global variable becomes available: msg.value.

msg.value holds the amount of Ether sent with the transaction that called the function. The critical point is that msg.value is always denominated in Wei, regardless of how the user specified the amount in their wallet interface.

The Readability Challenge with Wei
Since msg.value is in Wei, any comparisons or calculations you perform with it must also use Wei. Suppose you want to check if a user sent exactly 1 ETH to your payable function. You might initially write code like this:

@payable
def fund():
    # Check if exactly 1 ETH was sent
    assert msg.value == 1000000000000000000 # 1 ETH in Wei
    # ... rest of the function logic
While technically correct, the number 1000000000000000000 is extremely difficult to read. It's easy to miscount the zeros or make a typo, leading to subtle and potentially costly bugs. This poor readability makes the code hard to understand, review, and maintain.

The Vyper Solution: as_wei_value
Vyper provides a built-in utility function specifically designed to address this readability issue: as_wei_value. This function allows you to specify Ether values in your code using familiar units like "ether" or "gwei" and converts them into their Wei equivalent (uint256) automatically.

The syntax is: as_wei_value(value: uint256, unit: String[max_len]) -> uint256

Using as_wei_value, we can rewrite the previous example much more clearly:

@payable
def fund():
    # Check if exactly 1 ETH was sent
    assert msg.value == as_wei_value(1, "ether")
    # ... rest of the function logic
This code performs the exact same check as before (as_wei_value(1, "ether") evaluates to 1000000000000000000), but its intent is immediately obvious. You can also use other units:

as_wei_value(500, "gwei")

as_wei_value(1000000000, "wei") (though less common to use "wei" here)

While you could also represent 1 Ether using exponentiation (1 * (10 ** 18)), the as_wei_value function is generally preferred in Vyper as it explicitly signals that you are working with Ether denominations, enhancing code clarity.

Validating Conditions with assert
The assert statement is a fundamental control structure in Vyper used for checking conditions that must be true for the contract execution to proceed correctly. It's commonly used for validating inputs or state conditions.

Syntax: assert <condition>

If the <condition> evaluates to False, the assert statement triggers a revert. A revert immediately stops execution, undoes any state changes made during the transaction, and refunds the remaining gas to the caller.

In our example, assert msg.value == as_wei_value(1, "ether") checks if the Wei value sent with the transaction is exactly equal to 1 Ether in Wei. If not, the transaction reverts.

Improving Debugging with Revert Messages
When an assert fails, the transaction reverts, but without additional information, it can be difficult for users and developers to understand why it failed. Vyper allows you to add an optional revert message string to your assert statements:

Syntax: assert <condition>, "Revert message"

If the condition is false, this message is returned along with the revert information. This significantly improves the debugging experience.

@payable
def fund():
    # Check if exactly 1 ETH was sent, provide message on failure
    assert msg.value == as_wei_value(1, "ether"), "Error: Function requires exactly 1 ETH to be sent."
    # ... rest of the function logic
Now, if a user sends an incorrect amount, they (or a developer inspecting the transaction) will receive the specific message "Error: Function requires exactly 1 ETH to be sent," making the problem clear. Always include informative revert messages in your checks.

Essential Distinction: Assignment (=) vs. Equality (==)
A common source of confusion for programmers new to languages like Vyper (and many others) is the difference between the single equals sign (=) and the double equals sign (==).

= (Assignment Operator): Used to assign a value to a variable. Think of it as "set the value of".

amount_required: uint256 = as_wei_value(1, "ether") # Sets amount_required to 1 ETH in Wei
user_deposit: uint256 = msg.value                  # Sets user_deposit to the sent Wei amount
== (Equality Operator): Used to compare two values to see if they are equal. It evaluates to a boolean value (True or False). Think of it as "is equal to?". This is what's needed inside conditional checks like assert.

# Checks if the value in user_deposit is equal to the value in amount_required
assert user_deposit == amount_required, "Incorrect deposit amount."
â€‹
# Our previous example, checking msg.value directly
assert msg.value == as_wei_value(1, "ether"), "Incorrect deposit amount."
Using = where == is required (e.g., inside an assert) is a syntax error. Using == where = is required will often lead to unexpected behavior or errors. Remembering that assert requires a boolean condition (True/False) helps reinforce that the equality operator (==) is needed for comparisons within it. This distinction becomes second nature with practice.

In summary, always handle Ether values in Wei within your Vyper contracts, use as_wei_value for readable code, validate conditions like msg.value using assert with clear revert messages, and be mindful of the difference between assignment (=) and equality comparison (==).

Gwei Wei ETH
A crucial guide to Understanding Ether Denominations: Wei, Gwei, and ETH in Vyper - Learn why Vyper smart contracts operate in Wei and how to handle incoming Ether using `msg.value`. Master the `as_wei_value` function for readability and `assert` for validating Ether amounts correctly.


Previous lesson


Next lesson

Vyper Smart Contract Developer
Introduction to Python and Vyper
48%


Section 1: Favorites
Duration: 2h 08min
38/38


Section 2: Remix Coffee
Duration: 2h 33min
5/44


1. A Message From Curve
Learn more about Curve Finance @ https://news.curve.finance/
Duration: 1min

2. Introduction
An instructive introduction to Introduction to the Remix Buy Me A Coffee Project - Build the classic "Buy Me A Coffee" smart contract using Vyper and Remix. Learn core concepts like price feeds for USD minimums, payable functions, state storage, and owner-only withdrawals.
Duration: 4min

3. Setup
A foundational walkthrough to Setting Up Your First Vyper Project in Remix - Learn the initial steps for creating a Vyper smart contract in Remix, including environment setup and handling Remix quirks. Define basic requirements, structure your contract with pragma/NatSpec, and create initial function skeletons with pass and @external.
Duration: 4min

4. Doc Strings
An essential introduction to Documenting Vyper Code with Docstrings - Discover the standard syntax and purpose of multi-line docstrings for explaining Vyper functions, enhancing code clarity and maintainability.
Duration: 1min

5. Sending ETH
A fundamental guide to Sending and Receiving Ether in Vyper Smart Contracts - Learn how blockchain transactions carry native currency via the `value` field and how Vyper functions use the `@payable` decorator to accept these funds. Understand how to access the sent amount with `msg.value` (in Wei) and enforce specific funding requirements using `assert`.
Duration: 2min

6. Gwei Wei ETH
A crucial guide to Understanding Ether Denominations: Wei, Gwei, and ETH in Vyper - Learn why Vyper smart contracts operate in Wei and how to handle incoming Ether using `msg.value`. Master the `as_wei_value` function for readability and `assert` for validating Ether amounts correctly.
Duration: 4min

7. Send Tx
A practical guide to Sending Ether with Smart Contract Function Calls in Remix - Learn how to send Ether to `@payable` functions using the Remix interface, validate amounts with `msg.value` and `assert`, and understand transaction reverts.
Duration: 2min

8. Reverts
An essential guide to Understanding Reverts in Vyper - Explore the critical role of reverts in Vyper for ensuring contract integrity and handling errors. Understand how `assert` triggers reverts, their impact on state changes, and gas consumption implications.
Duration: 5min

9. Chainlink
An essential guide to Integrating Real-World Data using Chainlink Oracles - Learn about the critical need for off-chain data in smart contracts and the limitations imposed by the Oracle Problem. See how Chainlink's decentralized oracles, particularly Data Feeds, offer a secure solution for accessing reliable price information on-chain.
Duration: 13min

10. Mid Recap
A foundational overview to Handling Ether, Ensuring Validity, and the Oracle Problem in Vyper - Learn how Vyper contracts accept Ether via `@payable`, validate conditions using `assert`, and handle transaction reverts. Understand the critical challenge of accessing off-chain data, known as the Oracle Problem.
Duration: 1min

11. Quiz 1
Questions: 17

12. Chainlink In Vyper
A practical guide to Integrating Chainlink Price Feeds in Vyper - Learn how to fetch real-time asset prices like ETH/USD within your Vyper smart contracts using Chainlink. Understand the process of finding feed addresses and correctly interpreting price data with decimals.
Duration: 4min

13. ABI
A foundational explanation to Understanding the Application Binary Interface (ABI) - Discover what the ABI is, why it's crucial for smart contract interaction, and how to find and interpret its JSON structure in Remix IDE. Learn how it defines the contract's callable functions and enables communication.
Duration: 1min

14. In-Line Interface
A practical guide to Using In-Line Interfaces in Vyper for Smart Contract Interaction - Learn how to define interaction blueprints directly within your Vyper contract and use them to securely call functions on external deployed contracts like Chainlink.
Duration: 5min

15. Quiz 2
Questions: 7

16. Staticcall
A secure guide to Reading Data from External Contracts with Vyper's `staticcall` - Learn how Vyper uses interfaces and the mandatory `staticcall` keyword to safely read data from external smart contracts marked `view` or `pure`. Understand this explicit, security-focused approach for read-only interactions.
Duration: 2min

17. Tenderly 1
A practical guide to Deploying Vyper Contracts to a Tenderly Virtual Network - Master deploying Vyper contracts to Tenderly Virtual Networks via Remix IDE. Learn how these forked environments enable testing interactions with external contracts like Chainlink, understanding ABI and interfaces.
Duration: 3min

18. AI
A practical guide to Using AI to Understand Smart Contract Code - Learn how to effectively prompt AI assistants with context and formatted code to decipher complex smart contract elements like `staticcall`. Understand why verifying AI explanations is crucial for accurate learning.
Duration: 4min

19. Deploy Parameter
A strategic approach to Parameterizing Deployment for Flexible Vyper Contracts - Discover how to inject external dependencies like price feed addresses at deployment time using constructor arguments, making Vyper contracts adaptable across blockchains.
Duration: 3min

20. Integer Precision
An essential explanation to Handling Decimal Precision in Smart Contracts: Normalizing Price Feed Data - Delve into the common problem of mismatched decimal precision when using external data like Chainlink price feeds (8 decimals) with native blockchain values like Ether (18 decimals). Discover how to normalize these values in Vyper to enable accurate calculations.
Duration: 2min

21. Converting Types
A practical guide to Converting Types in Vyper using `convert()` - Understand Vyper's strict type system and the common `TypeMismatch` error between signed (`int256`) and unsigned (`uint256`) integers. Discover how to use the built-in `convert()` function for safe and explicit type casting in your smart contracts.
Duration: 1min

22. Integer Division
An essential guide to Handling Value Conversion and Precision with Integer Division in Vyper - Master fixed-point arithmetic in Vyper by scaling values with different decimals (like Wei and oracle prices) and using integer division (`//`) to manage precision. Ensure accurate and deterministic value comparisons and calculations in your smart contracts.
Duration: 8min

23. As Wei Value
A practical guide to Handling Decimal Precision in Vyper: Using `as_wei_value` - Learn to avoid common errors from mismatched decimal precision when comparing values like ETH and USD, and see why `as_wei_value` is the best practice for clarity and correctness.
Duration: 2min

24. Send ETH In Tx
A practical guide to Interacting with Payable Functions in Vyper - Learn how to send Ether to Vyper smart contracts using `@payable` functions via Remix and MetaMask. Understand how to calculate the correct ETH amount based on USD requirements using Chainlink Price Feeds.
Duration: 2min

25. Contract To Contract
A practical guide to Exposing Internal Logic with External Wrappers in Vyper - Learn how to securely expose internal Vyper functions using external wrappers. Understand the benefits of this pattern for controlled access, code organization, and maintaining encapsulation.
Duration: 1min

26. Quiz 3
Questions: 15

27. Getting Revert
An essential walkthrough to Verifying Smart Contract Reverts: Testing Minimum Funding Requirements - Discover how to test smart contract reverts caused by insufficient USD funding, focusing on Vyper's `assert`, required Wei calculations, and verifying failure conditions using development tools.
Duration: 3min

28. msg.sender
A fundamental guide to Securing Withdrawals with msg.sender in Vyper - Learn how to implement owner-only access control by storing the deployer's address using `__init__` and `msg.sender`. Discover how `assert` statements verify the caller, preventing unauthorized function execution like withdrawals.
Duration: 5min

29. Withdraw ETH
A practical walkthrough to Sending ETH From Your Vyper Contract - See how to securely implement an ETH withdrawal function in Vyper using `send` and `self.balance`. Understand the importance of owner verification and essential testnet testing steps.
Duration: 4min

30. Dynamic vs Fixed Array
A foundational exploration to Enhancing Our Contract: Tracking Funders - Explore Vyper's array types, contrasting dynamic `DynArray` with fixed-size arrays for storing funder data. Understand key differences in size, initialization, and element access methods.
Duration: 9min

31. Resetting Array
A clear walkthrough to Resetting Dynamic Array State Variables in Vyper - Understand how to declare Vyper's `DynArray` with a max size, add elements using `.append()`, and efficiently clear the array using `[]`. See how this applies to resetting a funder list in a smart contract.
Duration: 2min

32. Plus Equals
A practical guide to Tracking Total Contribution Amounts per Funder - Learn how to implement contribution tracking in Vyper using a `HashMap` to map funder addresses to their total amounts donated in Wei. Understand how to update this state variable within the `fund` function using `msg.sender` and `msg.value`.
Duration: 2min

33. For Loops
A crucial examination of Mastering For Loops in Vyper: Iteration and State Resets - Understand why `for` loops are vital for resetting Vyper mappings, learn the syntax variations, and grasp the significant gas cost differences compared to array resets.
Duration: 8min

34. Tenderly 2
A hands-on walkthrough to Testing Vyper Smart Contracts with Tenderly and Remix - Learn to perform end-to-end tests on a Vyper contract using Remix, MetaMask, and a Tenderly Virtual Testnet. Simulate funding, test owner-only withdrawal, and verify state changes for robust contract validation.
Duration: 7min

35. Immutables and Constants
An efficiency-driven look into Optimizing Vyper Contracts with Immutables and Constants - Discover how Vyper's `constant` and `immutable` keywords save gas and improve code clarity compared to standard state variables. Understand their distinct use cases and proper initialization techniques.
Duration: 4min

36. Natspec
An essential guide to Enhancing Vyper Contracts with Natspec Documentation - Learn to implement Ethereum Natspec using multi-line docstrings and standard tags (`@title`, `@author`, `@notice`) in Vyper contracts. Master the professional structure for contract-level documentation, enhancing readability and tooling integration.
Duration: 3min

37. Quiz 4
Questions: 16

38. Update Immute
A practical exploration to Reducing Gas Costs in Vyper: Using `constant` and `immutable` - Discover the gas-saving benefits of using `constant` (compile-time) and `immutable` (deploy-time) variables over standard storage in Vyper. Learn to refactor your smart contracts for improved efficiency and lower deployment/runtime costs.
Duration: 6min

39. Magic
A practical tutorial for Understanding and Refactoring the "Magic Numbers" Antipattern - Identify the 'magic number' antipattern in smart contracts and learn the best practice of using named constants in Vyper to enhance code clarity and ease maintenance.
Duration: 1min

40. Gas
A focused analysis to Gas Optimization with Vyper Constants and Immutables - Delve into the gas cost implications of using `constant` and `immutable` versus storage variables in Vyper. Learn how avoiding `SSTORE` and `SLOAD` operations leads to cheaper contract deployment and interactions.
Duration: 5min

41. Fallback
A practical guide to Understanding Vyper's `__default__` Fallback Function - Learn how this special function enables contracts to receive direct Ether transfers and handle unmatched function calls, ensuring robust fund acceptance through proper implementation and refactoring.
Duration: 7min

42. Better Way To Send
A critical approach to Securely Sending Ether in Vyper: Using `raw_call` - Delve into the pitfalls of the `send()` function and master the secure `raw_call` method for transferring Ether, leveraging its revert-on-failure feature.
Duration: 3min

43. Recap
A practical review to Vyper Fundamentals Recap: Building the "Buy Me A Coffee" Contract - Reinforce core Vyper concepts like state management, function types, interfaces, and data structures through the "Buy Me A Coffee" contract. Understand NatSpec documentation, external calls, oracle interaction, and precision handling before moving beyond Remix.
Duration: 9min

44. Quiz 5
Questions: 11

Section 3: Ai
Duration: 24min
0/7


Give us feedback!

Cyfrin
Updraft
CodeHawks
Solodit
Resources
Powered by Cyfrin
Video: Remix Coffee - Gwei Wei ETH - Introduction to Python and Vyper